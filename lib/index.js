// Generated by CoffeeScript 1.10.0
var SolidityCoder, Web3,
  slice = [].slice;

Web3 = require('web3');

SolidityCoder = require("web3/lib/solidity/coder.js");

module.exports = function(config, publisher) {
  var buildGenericMethods, callFromABI, contractAtAddress, ethAddress, eth_ip, getBalance, optionsOrDefaults, pollAndReturnReceipt, web3;
  web3 = new Web3();
  eth_ip = config.eth_ip || '127.0.0.1';
  web3.setProvider(new web3.providers.HttpProvider("http://" + eth_ip + ":8545"));
  optionsOrDefaults = function(options) {
    var account, gas, value;
    value = options.value, gas = options.gas, account = options.account;
    return {
      value: value || 1000000,
      gas: gas || 1000000,
      account: account || null
    };
  };
  getBalance = function(account, cb) {
    return web3.eth.getBalance(account, function(err, balance) {
      return cb(err, balance);
    });
  };
  ethAddress = function() {
    return config.eth_addresses[0];
  };
  contractAtAddress = (function(_this) {
    return function(source, name, address, cb) {
      return web3.eth.compile.solidity(source, function(err, compiled) {
        if (err != null) {
          console.log(err);
        }
        console.log(err, compiled);
        return web3.eth.contract(compiled[name].info.abiDefinition).at(address, cb);
      });
    };
  })(this);
  pollAndReturnReceipt = function(txid, cb) {
    var address_checker, i, publishReceipt;
    i = 0;
    publishReceipt = function(tx_receipt) {
      if (publisher != null) {
        return publisher.publish("tx:" + txid + ":done");
      }
    };
    return address_checker = setInterval(function() {
      return web3.eth.getTransactionReceipt(txid, function(err, resp) {
        console.log('Polling for a receipt...', resp);
        if (resp != null ? resp.contractAddress : void 0) {
          cb(err, resp.contractAddress);
          clearInterval(address_checker);
          return publishReceipt(resp);
        } else if (resp != null ? resp.blockNumber : void 0) {
          cb(err, resp);
          clearInterval(address_checker);
          return publishReceipt(resp);
        } else if (i++ > 1000) {
          return cb("Took forever and no receipt");
        }
      });
    }, 2000);
  };
  callFromABI = function() {
    var abi, address, args, cb, fn, j;
    abi = arguments[0], address = arguments[1], fn = arguments[2], args = 5 <= arguments.length ? slice.call(arguments, 3, j = arguments.length - 1) : (j = 3, []), cb = arguments[j++];
    console.log.apply(console, ['[callFromABI]', abi, address, fn].concat(slice.call(args)));
    return web3.eth.contract(abi).at(address, function(err, Contract) {
      var ref;
      return (ref = Contract[fn]).call.apply(ref, slice.call(args).concat([function(err, resp) {
        console.log(err, resp);
        if (err != null) {
          return cb(err);
        }
        return cb(null, resp);
      }]));
    });
  };
  buildGenericMethods = function(contract_schema) {
    var Contracts;
    Contracts = {};
    Object.keys(contract_schema).map(function(name) {
      var source;
      source = contract_schema[name];
      return Contracts[name] = {
        atAddress: function(address, cb) {
          return contractAtAddress(source, name, address, cb);
        },
        compile: function(cb) {
          return web3.eth.compile.solidity(source, function(err, compiled) {
            console.log(err, compiled);
            return cb(err, compiled[name]);
          });
        }
      };
    });
    return {
      getParameter: function() {
        var address, args, cb, j, name, parameter;
        name = arguments[0], address = arguments[1], parameter = arguments[2], args = 5 <= arguments.length ? slice.call(arguments, 3, j = arguments.length - 1) : (j = 3, []), cb = arguments[j++];
        return Contracts[name].atAddress(address, function(err, resp) {
          var ref;
          return (ref = resp[parameter]) != null ? ref.call.apply(ref, slice.call(args).concat([function(err, resp) {
            if (err != null) {
              console.log(err);
            }
            return cb(err, resp);
          }])) : void 0;
        });
      },
      callFunction: function() {
        var address, args, cb, fn, j, name, options;
        name = arguments[0], address = arguments[1], fn = arguments[2], args = 6 <= arguments.length ? slice.call(arguments, 3, j = arguments.length - 2) : (j = 3, []), options = arguments[j++], cb = arguments[j++];
        return Contracts[name].atAddress(address, function(err, resp) {
          var account, gas, tx_options, value;
          console.log.apply(console, ["Calling " + fn + " with args"].concat(slice.call(args)));
          if (err != null) {
            return cb(err);
          }
          if (resp[fn] == null) {
            return cb('This is not a function');
          }
          account = options.account, value = options.value, gas = options.gas;
          tx_options = {
            from: account || ethAddress(),
            to: address,
            value: value,
            gas: gas
          };
          web3.eth.estimateGas(tx_options, function(err, resp) {
            return console.log('Estimated gas', resp);
          });
          return resp[fn].apply(resp, slice.call(args).concat([tx_options], [function(err, resp) {
            return cb(err, resp);
          }]));
        });
      },
      sendTransaction: function(name, address, amount, cb) {
        return Contracts[name].atAddress(address, function(err, resp) {
          if (err != null) {
            console.log(err);
          }
          console.log("Sending " + amount + " to " + address);
          return web3.eth.estimateGas({
            from: ethAddress(),
            to: address,
            value: amount
          }, function(err, est_gas) {
            var gas;
            if (err != null) {
              cb(err);
            }
            console.log("Estimate " + est_gas + " gas is needed");
            if (est_gas === 50000000) {
              console.log("This will take way too much gas for the gas limit...");
            }
            if (est_gas > 1000) {
              gas = est_gas + 10000;
            } else {
              gas = 1000;
            }
            return web3.eth.sendTransaction({
              from: ethAddress(),
              to: address,
              value: amount,
              gas: gas
            }, function(err, resp) {
              if (err) {
                console.log(err);
              }
              if (err != null) {
                return cb(err);
              }
              return pollAndReturnReceipt(resp, function(err, receipt) {
                if (receipt.gasUsed === gas) {
                  console.log('[WARNING] It used all the gas');
                }
                return cb(err, receipt);
              });
            });
          });
        });
      },
      deploy: function() {
        var args, cb, j, name, options;
        name = arguments[0], args = 4 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 2) : (j = 1, []), options = arguments[j++], cb = arguments[j++];
        console.log.apply(console, [name].concat(slice.call(args), [options]));
        return Contracts[name].compile(function(err, compiled) {
          var _contract, abi, account, code, ref, tx_options, value;
          if (err) {
            return cb(err);
          }
          if (err != null) {
            console.log('Compilation error', err);
          }
          console.log('Successfully compiled', compiled);
          abi = compiled.info.abiDefinition;
          code = compiled.info.code;
          _contract = (ref = web3.eth).contract.apply(ref, [abi].concat(slice.call(args)));
          account = options.account, value = options.value;
          tx_options = {
            from: account || ethAddress(),
            data: compiled.code,
            value: value
          };
          return web3.eth.estimateGas(tx_options, function(err, resp) {
            var gas;
            console.log('estimated gas', resp);
            if (err != null) {
              return cb(err);
            }
            if (resp > 1000) {
              gas = resp + 10000;
            } else {
              gas = 1000;
            }
            tx_options.gas = options.gas;
            return _contract["new"].apply(_contract, slice.call(args).concat([tx_options], [function(err, contract) {
              console.log(err, contract, 'Completed deploy ^^^^^');
              return cb(err, contract);
            }]));
          });
        });
      },
      publishContract: function() {
        var args, cb, j, name, options;
        name = arguments[0], args = 4 <= arguments.length ? slice.call(arguments, 1, j = arguments.length - 2) : (j = 1, []), options = arguments[j++], cb = arguments[j++];
        console.log.apply(console, [name].concat(slice.call(args), [options]));
        return Contracts[name].compile(function(err, compiled) {
          var _contract, abi, account, code, ref, tx_options, value;
          if (err) {
            return cb(err);
          }
          if (err != null) {
            console.log('Compilation error', err);
          }
          console.log('Successfully compiled', compiled);
          abi = compiled.info.abiDefinition;
          code = compiled.info.code;
          _contract = (ref = web3.eth).contract.apply(ref, [abi].concat(slice.call(args)));
          account = options.account, value = options.value;
          tx_options = {
            from: account || ethAddress(),
            data: compiled.code,
            value: value
          };
          return web3.eth.estimateGas(tx_options, function(err, resp) {
            var gas;
            console.log('estimated gas', resp);
            if (err != null) {
              return cb(err);
            }
            if (resp > 1000) {
              gas = resp + 10000;
            } else {
              gas = 1000;
            }
            tx_options.gas = options.gas;
            return _contract["new"].apply(_contract, slice.call(args).concat([tx_options], [function(err, contract) {
              console.log(err, contract, 'Completed deploy ^^^^^');
              return cb(err, contract);
            }]));
          });
        });
      },
      compileContractData: function(name, address, cb) {
        return Contracts[name].atAddress(address, function(err, resp) {
          return cb(err, resp.abi);
        });
      }
    };
  };
  return {
    web3: web3,
    SolidityCoder: SolidityCoder,
    callFromABI: callFromABI,
    buildGenericMethods: buildGenericMethods
  };
};
